---
date: '2023-03-19'
title: '모던 JS Deep Dive - 5. 표현식과 문'
categories: ['Web Frontend', 'TIL', 'JavaScript']
summary: '값, 리터럴, 표현식, 문'
thumbnail: './javascript.png'
---

# 5. 표현식과 문 - 모던 딥 다이브 자바스크립트

## 5.1 값

- **값(value)은 식(표현식,expression)이 평가(evaluate)되어 생성된 결과**
- **평가**란 식을 해석하거나 값을 생성하거나 참조하는 것

  ```tsx
  // 10 + 20은 평가되어 숫자 값 30을 생성한다.
  10 + 20;
  ```

- 모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트(bit)의 나열로 저장됨.
- 메모리 저장된 값은 타입에 따라 다르게 해석 될 수 있다.
  - ex) 메모리 저장된 값 0100 0001 숫자로 해석하면 65, 문자로 해석하면 ‘A’
- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름. 따라서 **변수에 할당되는 것은 값**.

  ```tsx
  // 변수에는 10 + 20은 평가되어 생성된 숫자 값 30이 할당된다.
  var sum = 10 + 20;
  ```

- 값은 다양한 방법으로 생성할 수 있다. 가장 기본적인 방법은 리터럴을 사용하는 것.

## 5.2 리터럴

- **리터럴(literal)** 은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(notation). 사람이 이해할 수 있는 문자 또는 미리 약속된 기호로 표기한 코드

    ```tsx
    // 숫자 리터럴 3
    3
    ```

- 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 코드에 기술하면 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성.

<figure>
  <img src="./modern js deep dive/5literal.jpeg" style="max-width:300px margin:0 auto;"/>
  </figure>

- 자바스크립트 엔진은 코드가 실행되는 시점인 런타임에 리터럴을 평가해 값을 생성
- 리터럴은 값을 생성하기 위해 미리 약속한 표기법.

<figure>
  <img src="./modern js deep dive/5literal_table.jpeg" style="max-width:400px margin:0 auto;"/>
</figure>

## 5.3 표현식

- **표현식(expression)은 값으로 평가될 수 있는 문(statement)**
- 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조.
- 아래 코드 50은 리터럴이며 리터럴 50+50은 자바스크립트 엔진에 의해 평가되어 값 100을 생성하므로 리터럴은 그 자체로 표현식

  ```tsx
  var score = 50 + 50;
  ```

- 변수 식별자를 참조하면 변수 값으로 평가된다. 식별자 참조는 값을 생성하지 않지만 값으로 평가되므로 표현식

  ```tsx
  score; // ->100
  ```

- 표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.
- **값으로 평가될 수 있는 문은 모두 표현식**

  ```tsx
  // 리터럴 표현식
  10
  'Hello'

  // 식별자 표현식(선언이 이미 존재한다고 가정)
  sum
  person.name
  arr[1]

  // 연산자 표현식
  10 + 20
  sum = 10
  sum !== 10

  // 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
  square()
  person.getName()
  ```

- 표현식은 값으로 평가된다. 표현식과 표현식이 평가된 값은 동등한 관계, 즉 **동치(equivalent).**
- ex) 1+2 = 3에서 1+2는 3과 동치
- 따라서, **표현식은 값처럼 사용할 수 있고 문법적으로 값이 위치할 수 있는 자리에도 표현식도 위치할 수 있다는 것을 의미**

  ```tsx
  var x = 1 + 2;
  // 식별자 표현식 x는 3으로 평가된다.
  x + 3 // 6
  ```

## 5.4 문

- **문(statement)** 은 프로그램을 구성하는 기본 단위이자 **최소 실행 단위**
- 문의 집합으로 이뤄진 것이 바로 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다.
- 문은 여러 토큰으로 구성된다.
- **토큰(token)** 이란 문법적인 의미를 가지며, **문법적으로 더 이상 나눌 수 없는 코드의 기본 요소**를 의미

<figure>
  <img src="./modern js deep dive/5token.jpeg" style="max-width:400px margin:0 auto;"/>
</figure>

- 예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론(;)이나 마침표(.)등의 특수 기호는 문법적 의미를 가지며, 더이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다.
- 문을 명령문이라고도 부른다. 문은 컴퓨터에 내리는 명령이다.
- 문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

  ```tsx
  // 변수 선언문
  var x;

  // 표현식 문(할당문)
  x = 5;

  // 함수 선언문
  function foo () {}

  // 조건문
  if (x > 1) { console.log(x); }

  // 반복문
  for (var i = 0; i < 2; i++) { console.log(i); }
  ```

## 5.5 세미 콜론과 세미콜론 자동 삽입 기능

- 세미콜론(;)은 문의 종료를 나타내며 자바스크립트 엔진은 ;으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.
- 단, 0개 이상의 문을 중괄호로 묶은 코드블록 { } 뒤에는 세미콜론을 붙이지 않는다.
- 예로 if문, for문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 또한, 세미콜론은 옵션이다(생략 가능).
- 자바스크립트 엔진이 소스 코드 해석 시, 문의 끝이라고 예측되는 지점에 세미클론 자동 삽입 기능(ASI, automatic semicolon insertion)이 암묵적으로 수행됨으로써 자동으로 세미클론을 붙여준다.
- 하지만 간혹 예측하지 못한 형태로 실행될 수 있으니 유의해야 한다.

    ```tsx
    function foo () {
      return
        {}
      // ASI의 동작 결과 => return; {};
      // 개발자의 예측 => return {};
    }
    
    console.log(foo()); // undefined
    
    var bar = function () {}
    (function() {})();
    // ASI의 동작 결과 => var bar = function () {}(function() {})();
    // 개발자의 예측 => var bar = function () {}; (function() {})();
    // TypeError: (intermediate value)(...) is not a function
    ```

- 세미클론을 반드시 붙여야하는지에 대한 의견이 나뉘지만, **ESLint**같은 정적 분석 도구에서 세미클론 사용을 기본으로 설정하고 있고 **TC39(ECMAScript 기술 위원회**)도 세미클론 사용을 권장한다.

## 5.6 표현식인 문과 표현식이 아닌 문

- 표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수 있음

    ```tsx
    // 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
    var x;
    // 1, 2, 1 + 2, x = 1 + 2는 모두 표현식이다.
    // x = 1 + 2는 표현식이면서 완전한 문이기도 하다.
    x = 1 + 2;
    ```

### **표현식과 문 구별 방법**

- 문에는 표현식인 문과 표현식이 아닌 문이 있다.
  - 표현식인 문은 값으로 평가될 수 있는 문, 표현식이 아닌 문은 값으로 평가될 수 없는 문
  - ex) 변수 선언문은 값으로 평가될 수 없다. ⇒ 표현식이 아닌 문.
  - ex) 할당문은 값으로 평가될 수 있다. ⇒ 표현식인 문
- **가장 간단 명료한 방법은 변수에 할당해보는 것**

  ```tsx
  // 표현식이 아닌 문은 값처럼 사용할 수 없다.
  var foo = var x; // SyntaxError: Unexpected token var
  ```

  ```tsx
  // 변수 선언문은 표현식이 아닌 문이다.
  var x;

  // 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.
  x = 100;
  ```

  ```tsx
  // 표현식인 문은 값처럼 사용할 수 있다
  var foo = x = 100;
  console.log(foo); // 100
  ```

### cf) 완료 값(completion value)

- 크롬 개발자 도구에서 표현식이 아닌 문을 실행하면 언제나 undefined를 출력하는데, 이를 완료 값이라고 한다.
- 완료값은 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조도 할수 없다.

    <figure>
  <img src="./modern js deep dive/5completionvalue_1.png" style="max-width:400px margin:0 auto;"/>
  </figure>

- 크롬 개발자 도구에서 표현식인 문을 실행하면 언제나 평가된 값을 반환한다.

    <figure>
  <img src="./modern js deep dive/5completionvalue_2.png" style="max-width:400px margin:0 auto;"/>
  </figure>

# **출처**

- 이웅모, **『모던 자바스크립트 Deep Dive 자바스크립트의 기본 개념과 동작 원리』**, 위키북스(2020).
